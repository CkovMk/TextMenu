[TOC]

## 应用指南

### 依赖项与初始化

by：CkovMk @hitsic 2020.10.13

内容已更新以适配v0.1.4版本。

#### 初始化步骤

- 在主函数初始化阶段依次调用PITMGR、EXTMGR、FLASH、OLED、MENU的初始化函数。这些函数都没有参数，具体内容详见头文件内的函数注释，在此不再说明。 **注意：按键BUTTON的初始化已包含在MENU内部，不需要手动初始化。**

  > 代码清单1
  >
  > ```c
  > void main()
  > {
  > 	/** 初始化阶段，关闭总中断 */
  > 	HAL_EnterCritical();
  > 
  > 	/** 其他初始化代码 */
  > 
  > 	/** 初始化PIT中断管理器 */
  > 	PITMGR_Init();
  > 	/** 初始化I/O中断管理器 */
  > 	EXTINT_Init();
  > 	/** 初始化ftfx_Flash */
  > 	FLASH_SimpleInit();
  > 	/** 初始化OLED屏幕 */
  > 	OLED_Init();
  > 	/** 初始化菜单 */
  > 	MENU_Init();
  >    /** 读取NVM中保存的存储区号 */
  > 	MENU_Data_NvmReadRegionConfig();
  >  /** 读取全局存储区和局部存储区 */
  > 	MENU_Data_NvmRead(menu_currRegionNum);
  > 
  > 	/** 其他初始化代码 */
  > 
  > 	/** 初始化结束，开启总中断 */
  > 	HAL_ExitCritical();
  > 	while(1)
  > 	{
  > 	      /** 无限循环 */
  > 	}
  > }
  > ```

  

- 此时应该就可以编译通过并运行了。屏幕上将显示Demo界面。

#### 注意事项

- 菜单初始化时必须关闭总中断。事实上，整个初始化阶段均应关闭总中断。如无特殊情况，开启总中断应该是主函数进入死循环前的最后一条语句。
- 菜单本体初始化前必须完成OLED模组及NVM模组（一般是Flash）的初始化，且所有按键所在引脚必须为释放状态。**注意：如果按键初始化时为按下状态，初始化将被永久阻塞，直到按键释放。**



### 创建自己的菜单

by：CkovMk @hitsic 2020.10.13

内容已更新以适配v0.1.4版本。

- 在合适的位置创建`void MENU_DataSetUp(void)`新的实现。原函数已声明为弱符号`__WEAK`，新定义将自动覆盖旧定义，不会产生重复定义的错误。**注意：禁止在`app_menu.c`中直接修改代码！**该函数会在初始化时被`MENU_Init(void);`函数调用，禁止手动调用。

- 添加自己的菜单项。

  - 构造菜单项：调用`MENU_ItemConstruct`。
  - 添加菜单项：调用`MENU_ListInsert`。
  - 添加子菜单：先调用`MENU_ListConstruct`构造菜单列表，再调用`MENU_ItemConstruct`和`MENU_ListInsert`向上级菜单插入跳转菜单项。

  > 代码清单1
  >
  > ```c
  > /** 在其他位置创建的MENU_DataSetup函数 */
  > 
  > /** 创建子菜单指针 */
  > menu_list_t* myList_1;
  > 
  > /** 这些变量仅用于示例 */
  > int32_t testInt = 19981214;
  > float testFlt = 3.1415926f;
  > 
  > void ExampleHandler(menu_keyOp_t* const _op)
  > {
  >  *_op = 0;
  > }
  > 
  > void MENU_DataSetUp(void)
  > {
  >  MENU_ListInsert(menu_menuRoot, MENU_ItemConstruct(nullType, NULL, "", 0, 0));
  > 
  > /** 子菜单指针初始化 */
  >  myList_1 = MENU_ListConstruct(
  >      "myList_1",     ///> 菜单标题，在菜单列表中的第一行显示，最大12字符。
  >      50,             ///> 菜单列表的大小，须预留1位用于返回上一级的[back]。
  >      menu_menuRoot   ///> 该菜单的上级菜单指针。注意：该指针仅用于返回上级菜单，并不会将子菜单插入上级菜单。
  >  );
  > /** 检查内存分配是否成功 */
  >  assert(testList);
  > /** 将子菜单的跳转入口插入其上级菜单 */
  >  MENU_ListInsert(
  >      menu_menuRoot,  ///> 要插入的上级菜单。
  >      MENU_ItemConstruct(
  >      menuType,   ///> 类型标识，指明这是一个菜单跳转类型的菜单项。
  >      myList_1,   ///> 数据指针，这里指向要跳转到的菜单列表。
  >      "TestList", ///> 菜单项名称，在菜单列表中显示。
  >      0,          ///> 数据的保存位置，对于非数据类型填0即可。
  >      0           ///> 属性Flag，无任何属性填0。
  >  ));
  >  {   //这里加这组括号只是为了缩进方便，其内部的语句用于向myList_1插入菜单项。
  >      MENU_ListInsert(myList_1, MENU_ItemConstruct(
  >          variType,  ///> 类型标识，指明这是一个整数类型的菜单项
  >          &testInt,  ///> 数据指针，这里指向要操作的整数。必须是int32_t类型。
  >          "T_int",   ///> 菜单项名称，在菜单列表中显示。
  >          10,        ///> 数据的保存地址，不能重复且尽可能连续，步长为1。
  >                     ///> 全局数据区0~9的地址为保留地址，不能使用。
  >          menuItem_data_global | menuItem_data_ROFlag
  >                     ///> 属性flag。此flag表示该变量存储于全局数据区，且为只读变量。
  >      ));
  >      MENU_ListInsert(myList_1, MENU_ItemConstruct(
  >          varfType,  ///> 类型标识，指明这是一个浮点类型的菜单项
  >          &testFlt,  ///> 数据指针，这里指向要操作的整数。必须是float类型。
  >          "T_float", ///> 菜单项名称，在菜单列表中显示。
  >          0,         ///> 数据的保存地址，不能重复且尽可能连续，步长为1。
  >          menuItem_data_region
  >                     ///> 属性flag。此flag表示该变量存储于局部数据区。局部数据区内的数据没有保留地址。
  >      ));
  >  }
  >  MENU_ListInsert(menu_menuRoot, MENU_ItemConstruct(
  >        procType,  ///> 类型标识，指明这是一个浮点类型的菜单项
  >        &ExampleHandler,///> 数据指针，这里指向要操作的整数。必须是float类型。
  >        "T_proc ", ///> 菜单项名称，在菜单列表中显示。
  >        0,         ///> 数据的保存地址，不能重复且尽可能连续，步长为1。
  >        menuItem_proc_runOnce
  >                   ///> 属性flag。此flag表示该该程序运行一次就退出。
  >  ));
  > }
  > 
  > ```

- 设置好自己的菜单后，编译下载，就可以看到自己定义的菜单了。



### 菜单第一次启动

by CkovMk @hitsic 2020.10.30

菜单第一次启动时，由于NVM中未存储任何数据，将不会从NVM中加载数据。此时应对菜单的各个局部数据区分别执行一次保存操作，以初始化NVM存储。再次之后，菜单将在启动时读取NVM中存储的数据。



### 编写交互式的可执行菜单项

by CkovMk @hitsic 2020.11.22

本菜单模组支持运行交互式的可执行菜单项（下简称为“交互式菜单项”）。这允许您编写一个可在菜单中调用的应用程序，并可根据您的按键输入执行动作。示例代码为`app_menu_test.hpp`中的`inline void MENU_ExampleProcHandler1(menu_keyOp_t *const _op);`函数，对应示例菜单根目录中的`StrBufOvrd`菜单项。

##### 原理

为了让交互式菜单项能够连续响应用户的输入，该菜单项在执行时不应自动退出。因此，与大部分只运行一次的菜单项不同，您不应置位`menuItem_proc_runOnce`标志。交互式菜单项往往需要在屏幕上显示一些内容。因此，您应当置位`menuItem_proc_uiDisplay`标志。这将在该交互式菜单项执行时自动禁用菜单自带的提示界面，转而将屏幕显示交由您编写的的程序控制。在您的交互式菜单项退出后，菜单显示将自动恢复。

显然，您的菜单项需要处理按键输入。事件变量的指针由函数参数传入，其中包含了（可能的）按键操作信息。在执行完按键响应后，您需要清除该事件（即将指针指向的变量赋值为0）。**注意：在进行按键处理时，不可以刷新屏幕！**菜单逻辑保留了“长按确定键”的操作作为菜单“退出“的出口，您不必为您的交互式菜单项添加“退出”出口。但是，如果您的交互式菜单项在退出时需要释放资源，您就需要自行编写“退出”功能。请参阅`设计文档 - 核心逻辑 - 菜单状态变量（状态机）`部分。对于交互式菜单项，除了常见的按键事件以外，还有一个“屏幕打印”事件。在该事件发生时，交互式菜单项应仅进行打印屏幕的操作。

> 菜单的底层逻辑保证了在一次按键操作发生后，会立刻产生一个屏幕刷新事件。因此无需担心按键处理后屏幕刷新不及时的问题。

打印屏幕的操作详见`设计文档 - 外围组件 - 屏幕输出 `。一般情况下，菜单逻辑总是先刷新字符缓存，交互式菜单也不例外。如果您的交互式菜单仅打印字符，则直接向字符缓存写入打印内容即可。但如果您的交互式菜单需要打印图形，则需要置位菜单全局标志位`menu_message_strBufOverride`（字符缓存超控标志位）。这将在**一帧**的屏幕输出中禁用字符缓存，直接输出帧缓存。**注意：本帧打印结束后该标志位会自动清除，在每次打印时均需要手动置位。**

##### 例程

（未完待续）
